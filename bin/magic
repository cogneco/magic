#!/usr/bin/env node
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        var Position = (function () {
            function Position(line, column) {
                this.line = line;
                this.column = column;
            }
            Position.prototype.getLine = function () { return this.line; };
            Position.prototype.getColumn = function () { return this.column; };
            Position.prototype.toString = function () {
                return "Ln" + this.line + ", Col" + this.column;
            };
            return Position;
        })();
        Error.Position = Position;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
/// <reference path="Position" />
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        var Location = (function (_super) {
            __extends(Location, _super);
            function Location(resource, line, column) {
                _super.call(this, line, column);
                this.resource = resource;
            }
            Location.prototype.getResource = function () { return this.resource; };
            Location.prototype.toString = function () {
                return this.resource + " @ " + _super.prototype.toString.call(this);
            };
            return Location;
        })(Error.Position);
        Error.Location = Location;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
/// <reference path="Position" />
/// <reference path="Location" />
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        var Region = (function () {
            function Region(resource, start, end, content) {
                this.resource = resource;
                this.start = start;
                this.end = end;
                this.content = content;
            }
            Region.prototype.getResource = function () { return this.resource; };
            Region.prototype.getStart = function () { return this.start; };
            Region.prototype.getEnd = function () { return this.end; };
            Region.prototype.getContent = function () { return this.content; };
            Region.prototype.toString = function () {
                return this.resource + " (" + this.start.toString() + " - " + this.end.toString() + ") " + this.content;
            };
            return Region;
        })();
        Error.Region = Region;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        (function (Type) {
            Type[Type["Lexical"] = 0] = "Lexical";
            Type[Type["Gramatical"] = 1] = "Gramatical";
            Type[Type["Symbol"] = 2] = "Symbol";
            Type[Type["Type"] = 3] = "Type";
            Type[Type["Formatting"] = 4] = "Formatting";
            Type[Type["BestPractice"] = 5] = "BestPractice";
        })(Error.Type || (Error.Type = {}));
        var Type = Error.Type;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        (function (Level) {
            Level[Level["Logging"] = 0] = "Logging";
            Level[Level["Debug"] = 1] = "Debug";
            Level[Level["Warning"] = 2] = "Warning";
            Level[Level["Recoverable"] = 3] = "Recoverable";
            Level[Level["Critical"] = 4] = "Critical";
        })(Error.Level || (Error.Level = {}));
        var Level = Error.Level;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
/// <reference path="Type" />
/// <reference path="Level" />
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        var Message = (function () {
            function Message(description, level, type, region) {
                this.description = description;
                this.level = level;
                this.type = type;
                this.region = region;
            }
            Message.prototype.toString = function () {
                return this.level + ": " + this.type + " Error. " + this.description + " @ " + this.region.toString();
            };
            return Message;
        })();
        Error.Message = Message;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
/// <reference path="Level" />
/// <reference path="Type" />
/// <reference path="Region" />
/// <reference path="Message" />
/// <reference path="Level" />
/// <reference path="Type" />
/// <reference path="Region" />
/// <reference path="Message" />
/// <reference path="Handler" />
var Magic;
(function (Magic) {
    var Error;
    (function (Error) {
        var ConsoleHandler = (function () {
            function ConsoleHandler() {
            }
            ConsoleHandler.prototype.raise = function (message, level, type, region) {
                if (message instanceof String) {
                    message = new Error.Message(message, level, type, region);
                }
                console.log(message.toString());
            };
            return ConsoleHandler;
        })();
        Error.ConsoleHandler = ConsoleHandler;
    })(Error = Magic.Error || (Magic.Error = {}));
})(Magic || (Magic = {}));
/// <reference path="Iterator" />
var Magic;
(function (Magic) {
    var Utilities;
    (function (Utilities) {
        var BufferedIterator = (function () {
            function BufferedIterator(backend) {
                this.backend = backend;
            }
            BufferedIterator.prototype.peek = function (position) {
                if (position === void 0) { position = 0; }
                var next = null;
                while (position > this.buffer.length - 1 && (next = this.backend.next())) {
                    this.buffer.push(next);
                }
                return position > this.buffer.length - 1 ? null : this.buffer[position];
            };
            BufferedIterator.prototype.next = function () {
                var result = this.peek(0);
                if (this.buffer.length > 1) {
                    this.buffer.slice();
                }
                return result;
            };
            return BufferedIterator;
        })();
        Utilities.BufferedIterator = BufferedIterator;
    })(Utilities = Magic.Utilities || (Magic.Utilities = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Location" />
/// <reference path="../Error/Region" />
/// <reference path="../../typings/node/node" />
/// <reference path="../Error/Position" />
/// <reference path="../Error/Location" />
/// <reference path="../Error/Region" />
/// <reference path="../Error/Level" />
/// <reference path="../Error/Type" />
/// <reference path="Reader" />
var fs = require("fs");
var Magic;
(function (Magic) {
    var IO;
    (function (IO) {
        var StringReader = (function () {
            function StringReader(content, path) {
                if (path === void 0) { path = ""; }
                this.content = content;
                this.path = path;
            }
            StringReader.prototype.isEmpty = function () {
                return this.count >= this.content.length;
            };
            StringReader.prototype.read = function () {
                var result = this.count < this.content.length ? this.content.charAt(this.count++) : null;
                this.lastContent += result;
                if (result) {
                    if (result == "\n") {
                        this.line++;
                        this.column = 0;
                    }
                    else {
                        this.column++;
                    }
                }
                return result;
            };
            StringReader.prototype.getResource = function () { return this.path; };
            StringReader.prototype.getLocation = function () { return new Magic.Error.Location(this.path, this.line, this.column); };
            StringReader.prototype.getRegion = function () { return new Magic.Error.Region(this.path, this.lastPosition, new Magic.Error.Position(this.line, this.column), this.lastContent); };
            StringReader.prototype.mark = function () {
                var result = this.getRegion();
                this.lastPosition = new Magic.Error.Position(this.line, this.column);
                this.lastContent = "";
                return result;
            };
            return StringReader;
        })();
        IO.StringReader = StringReader;
    })(IO = Magic.IO || (Magic.IO = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Location" />
/// <reference path="../Error/Region" />
/// <reference path="Reader" />
var Magic;
(function (Magic) {
    var IO;
    (function (IO) {
        var BufferedReader = (function () {
            function BufferedReader(backend) {
                this.backend = backend;
                this.buffer = "";
            }
            BufferedReader.prototype.isEmpty = function () {
                return this.buffer.length == 0 && this.backend.isEmpty();
            };
            BufferedReader.prototype.peek = function (length) {
                if (length === void 0) { length = 1; }
                var next = null;
                while (length > this.buffer.length && (next = this.backend.read())) {
                    this.buffer += next;
                }
                return length > this.buffer.length ? null : this.buffer.slice(0, length - 1);
            };
            BufferedReader.prototype.read = function (length) {
                if (length === void 0) { length = 1; }
                var result = this.peek(length);
                if (this.buffer.length > 1) {
                    this.buffer = this.buffer.slice(1);
                }
                for (var i = 0; i < result.length; i++) {
                    switch (result.charAt(i)) {
                        case "\0":
                            this.column = 0;
                            this.line = 0;
                            break;
                        case "\n":
                            this.column = 0;
                            this.line++;
                            break;
                        default:
                            this.column++;
                            break;
                    }
                }
                this.lastContent += result;
                return result;
            };
            BufferedReader.prototype.getResource = function () { return this.backend.getResource(); };
            BufferedReader.prototype.getLocation = function () { return new Magic.Error.Location(this.getResource(), this.line, this.column); };
            BufferedReader.prototype.getRegion = function () { return new Magic.Error.Region(this.getResource(), this.lastMark, new Magic.Error.Position(this.line, this.column), this.lastContent); };
            BufferedReader.prototype.mark = function () {
                var result = this.getRegion();
                this.lastMark = new Magic.Error.Position(this.line, this.column);
                return result;
            };
            return BufferedReader;
        })();
        IO.BufferedReader = BufferedReader;
    })(IO = Magic.IO || (Magic.IO = {}));
})(Magic || (Magic = {}));
/// <reference path="../../typings/node/node" />
/// <reference path="StringReader" />
var fs = require("fs");
var Magic;
(function (Magic) {
    var IO;
    (function (IO) {
        var FileReader = (function (_super) {
            __extends(FileReader, _super);
            function FileReader(path) {
                _super.call(this, fs.readFileSync(path, "utf-8"), path);
            }
            return FileReader;
        })(IO.StringReader);
        IO.FileReader = FileReader;
    })(IO = Magic.IO || (Magic.IO = {}));
})(Magic || (Magic = {}));
/// <reference path="../../typings/node/node" />
/// <reference path="../Utilities/Iterator" />
/// <reference path="Reader" />
var fs = require("fs");
var Magic;
(function (Magic) {
    var IO;
    (function (IO) {
        var FolderReader = (function () {
            function FolderReader(path, pattern) {
                this.path = path;
                this.files = FolderReader.getFiles(this.path, pattern);
            }
            FolderReader.prototype.isEmpty = function () {
                return this.files.length == 0 && (!this.current || this.current.isEmpty());
            };
            FolderReader.prototype.read = function () {
                var result = null;
                if (!this.current && this.files.length > 0) {
                    this.current = new IO.FileReader(this.files.shift());
                }
                if (this.current) {
                    result = this.current.read();
                    if (result && this.files.length > 0) {
                        this.current = null;
                        result = "\0";
                    }
                }
                return result;
            };
            FolderReader.prototype.getResource = function () { return this.current ? this.current.getResource() : null; };
            FolderReader.prototype.getLocation = function () { return this.current.getLocation(); };
            FolderReader.prototype.getRegion = function () { return this.current.getRegion(); };
            FolderReader.prototype.mark = function () { return this.current.mark(); };
            FolderReader.getFiles = function (folder, filetype, ignoreFiles) {
                if (ignoreFiles === void 0) { ignoreFiles = []; }
                var result = [];
                var files = fs.readdirSync(folder);
                var filename = "";
                files.forEach(function (file) {
                    filename = folder + "/" + file;
                    if (ignoreFiles.indexOf(filename) == -1) {
                        if (fs.lstatSync(filename).isDirectory()) {
                            result = result.concat(FolderReader.getFiles(filename, filetype, ignoreFiles));
                        }
                        else if (file.length > filetype.length && file.lastIndexOf(filetype, file.length - filetype.length) === file.length - filetype.length) {
                            result.push(filename);
                        }
                    }
                });
                return result;
            };
            return FolderReader;
        })();
        IO.FolderReader = FolderReader;
    })(IO = Magic.IO || (Magic.IO = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="../IO/BufferedReader" />
/// <reference path="../Error/Handler" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Source = (function (_super) {
            __extends(Source, _super);
            function Source(reader, errorHandler) {
                _super.call(this, reader);
                this.errorHandler = errorHandler;
            }
            Source.prototype.raise = function (message, level, type, region) {
                if (level === void 0) { level = Magic.Error.Level.Critical; }
                if (type === void 0) { type = Magic.Error.Type.Lexical; }
                if (message instanceof String) {
                    if (!region) {
                        region = this.getRegion();
                    }
                    message = new Magic.Error.Message(message, level, type, region);
                }
                console.log(message.toString());
            };
            return Source;
        })(Magic.IO.BufferedReader);
        Tokens.Source = Source;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Token = (function () {
            function Token(region) {
                this.region = region;
            }
            Token.prototype.getRegion = function () { return this.region; };
            Token.prototype.toString = function () {
                return this.region.toString();
            };
            Token.prototype.isSeparator = function (symbol) {
                if (symbol === void 0) { symbol = null; }
                return false;
            };
            Token.prototype.isIdentifier = function (name) {
                if (name === void 0) { name = null; }
                return false;
            };
            Token.prototype.isOperator = function (symbol) {
                if (symbol === void 0) { symbol = null; }
                return false;
            };
            return Token;
        })();
        Tokens.Token = Token;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Token" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Gap = (function (_super) {
            __extends(Gap, _super);
            function Gap(region) {
                _super.call(this, region);
            }
            return Gap;
        })(Tokens.Token);
        Tokens.Gap = Gap;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Token" />
/// <reference path="Gap" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Substance = (function (_super) {
            __extends(Substance, _super);
            function Substance(region) {
                _super.call(this, region);
            }
            Substance.prototype.getPregap = function () { return this.pregap; };
            Substance.prototype.setPregap = function (value) { this.pregap = value; };
            Substance.prototype.getPostgap = function () { return this.postgap; };
            Substance.prototype.setPostgap = function (value) { this.postgap = value; };
            return Substance;
        })(Tokens.Token);
        Tokens.Substance = Substance;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Substance" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Identifier = (function (_super) {
            __extends(Identifier, _super);
            function Identifier(name, region) {
                _super.call(this, region);
                this.name = name;
            }
            Identifier.prototype.getName = function () {
                return this.name;
            };
            Identifier.prototype.isIdentifier = function (name) {
                if (name === void 0) { name = null; }
                return !name || name == this.name;
            };
            Identifier.scan = function (source) {
                var result;
                if (Identifier.isValidFirstCharacter(source.peek())) {
                    do {
                        result += source.read();
                    } while (Identifier.isValidWithinCharacter(source.peek()));
                }
                return result ? new Identifier(result, source.mark()) : null;
            };
            Identifier.isValidFirstCharacter = function (character) {
                return character >= "A" && character <= "Z" || character >= "a" && character <= "z" || character == "_";
            };
            Identifier.isValidWithinCharacter = function (character) {
                return Identifier.isValidFirstCharacter(character) || character >= "0" && character <= "9";
            };
            return Identifier;
        })(Tokens.Substance);
        Tokens.Identifier = Identifier;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Token" />
/// <reference path="Substance" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Literal = (function (_super) {
            __extends(Literal, _super);
            function Literal(region) {
                _super.call(this, region);
            }
            return Literal;
        })(Tokens.Substance);
        Tokens.Literal = Literal;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../../Error/Region" />
/// <reference path="../Source" />
/// <reference path="../Token" />
/// <reference path="../Literal" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Literals;
        (function (Literals) {
            var String = (function (_super) {
                __extends(String, _super);
                function String(value, region) {
                    _super.call(this, region);
                    this.value = value;
                }
                String.prototype.getValue = function () { return this.value; };
                String.scan = function (source) {
                    var result;
                    if (source.peek() == "\"") {
                        source.read();
                        result = "";
                        do {
                            if (source.peek() == "\"") {
                                switch (source.peek(2)) {
                                    case "\\0":
                                        result += "\0";
                                        break;
                                    case "\\\\":
                                        result += "\\";
                                        break;
                                    case "\\\"":
                                        result += "\"";
                                        break;
                                    case "\\n":
                                        result += "\n";
                                        break;
                                    case "\\r":
                                        result += "\r";
                                        break;
                                    default:
                                        source.raise("Unrecognized escape sequence: \"" + source.peek(2) + "\"");
                                        break;
                                }
                                source.read(2);
                            }
                            else {
                                result += source.read();
                            }
                        } while (source.peek() != "\"");
                        source.read();
                    }
                    return result ? new String(result, source.mark()) : null;
                };
                return String;
            })(Tokens.Literal);
            Literals.String = String;
        })(Literals = Tokens.Literals || (Tokens.Literals = {}));
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../../Error/Region" />
/// <reference path="../Source" />
/// <reference path="../Token" />
/// <reference path="../Literal" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Literals;
        (function (Literals) {
            var Number = (function (_super) {
                __extends(Number, _super);
                function Number(value, original, region) {
                    _super.call(this, region);
                    this.value = value;
                }
                Number.prototype.getValue = function () { return this.value; };
                Number.scan = function (source) {
                    return Number.scanHexadecimal(source);
                };
                Number.scanHexadecimal = function (reader) {
                    var result;
                    if (reader.peek(2) == "0x") {
                        var original = reader.read(2);
                        var value;
                        var divisor;
                        while (!result) {
                            switch (reader.peek()) {
                                case ".":
                                    original += reader.read();
                                    if (divisor)
                                        result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    else
                                        divisor = 1;
                                    continue;
                                case "_":
                                    original += reader.read();
                                    continue;
                                case "0":
                                    value += 0;
                                    original += reader.read();
                                    break;
                                case "1":
                                    value += 1;
                                    original += reader.read();
                                    break;
                                case "2":
                                    value += 2;
                                    original += reader.read();
                                    break;
                                case "3":
                                    value += 3;
                                    original += reader.read();
                                    break;
                                case "4":
                                    value += 4;
                                    original += reader.read();
                                    break;
                                case "5":
                                    value += 5;
                                    original += reader.read();
                                    break;
                                case "6":
                                    value += 6;
                                    original += reader.read();
                                    break;
                                case "7":
                                    value += 7;
                                    original += reader.read();
                                    break;
                                case "8":
                                    value += 8;
                                    original += reader.read();
                                    break;
                                case "9":
                                    value += 9;
                                    original += reader.read();
                                    break;
                                case "a":
                                    value += 10;
                                    original += reader.read();
                                    break;
                                case "b":
                                    value += 11;
                                    original += reader.read();
                                    break;
                                case "c":
                                    value += 12;
                                    original += reader.read();
                                    break;
                                case "d":
                                    value += 13;
                                    original += reader.read();
                                    break;
                                case "e":
                                    value += 14;
                                    original += reader.read();
                                    break;
                                case "f":
                                    value += 15;
                                    original += reader.read();
                                    break;
                                default:
                                    result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    continue;
                            }
                            value *= 16;
                            if (divisor)
                                divisor *= 16;
                        }
                    }
                    else {
                        result = null;
                    }
                    return result;
                };
                Number.scanDecimal = function (reader) {
                    var result;
                    var c = reader.peek();
                    if (Number.isNumber(c) || c == "." && Number.isNumber(reader.peek(2).slice(1, 2))) {
                        var original;
                        var value;
                        var divisor;
                        while (!result) {
                            switch (reader.peek()) {
                                case ".":
                                    original += reader.read();
                                    if (divisor)
                                        result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    else
                                        divisor = 1;
                                    continue;
                                case "_":
                                    original += reader.read();
                                    continue;
                                case "0":
                                    value += 0;
                                    original += reader.read();
                                    break;
                                case "1":
                                    value += 1;
                                    original += reader.read();
                                    break;
                                case "2":
                                    value += 2;
                                    original += reader.read();
                                    break;
                                case "3":
                                    value += 3;
                                    original += reader.read();
                                    break;
                                case "4":
                                    value += 4;
                                    original += reader.read();
                                    break;
                                case "5":
                                    value += 5;
                                    original += reader.read();
                                    break;
                                case "6":
                                    value += 6;
                                    original += reader.read();
                                    break;
                                case "7":
                                    value += 7;
                                    original += reader.read();
                                    break;
                                case "8":
                                    value += 8;
                                    original += reader.read();
                                    break;
                                case "9":
                                    value += 9;
                                    original += reader.read();
                                    break;
                                default:
                                    result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    continue;
                            }
                            value *= 10;
                            if (divisor)
                                divisor *= 10;
                        }
                    }
                    else {
                        result = null;
                    }
                    return result;
                };
                Number.isNumber = function (character) {
                    return character >= "0" && character <= "9";
                };
                Number.scanOctal = function (reader) {
                    var result;
                    if (reader.peek(2) == "0o") {
                        var original = reader.read(2);
                        var value;
                        var divisor;
                        while (!result) {
                            switch (reader.peek()) {
                                case ".":
                                    original += reader.read();
                                    if (divisor)
                                        result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    else
                                        divisor = 1;
                                    continue;
                                case "_":
                                    original += reader.read();
                                    continue;
                                case "0":
                                    value += 0;
                                    original += reader.read();
                                    break;
                                case "1":
                                    value += 1;
                                    original += reader.read();
                                    break;
                                case "2":
                                    value += 2;
                                    original += reader.read();
                                    break;
                                case "3":
                                    value += 3;
                                    original += reader.read();
                                    break;
                                case "4":
                                    value += 4;
                                    original += reader.read();
                                    break;
                                case "5":
                                    value += 5;
                                    original += reader.read();
                                    break;
                                case "6":
                                    value += 6;
                                    original += reader.read();
                                    break;
                                case "7":
                                    value += 7;
                                    original += reader.read();
                                    break;
                                default:
                                    result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    continue;
                            }
                            value *= 8;
                            if (divisor)
                                divisor *= 8;
                        }
                    }
                    else {
                        result = null;
                    }
                    return result;
                };
                Number.scanBinary = function (reader) {
                    var result;
                    if (reader.peek(2) == "0b") {
                        var original = reader.read(2);
                        var value;
                        var divisor;
                        while (!result) {
                            switch (reader.peek()) {
                                case ".":
                                    original += reader.read();
                                    if (divisor)
                                        result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    else
                                        divisor = 1;
                                    continue;
                                case "_":
                                    original += reader.read();
                                    continue;
                                case "0":
                                    value += 0;
                                    original += reader.read();
                                    break;
                                case "1":
                                    value += 1;
                                    original += reader.read();
                                    break;
                                default:
                                    result = new Number(divisor ? value / divisor : value, original, reader.mark());
                                    continue;
                            }
                            value *= 2;
                            if (divisor)
                                divisor *= 2;
                        }
                    }
                    else {
                        result = null;
                    }
                    return result;
                };
                return Number;
            })(Tokens.Literal);
            Literals.Number = Number;
        })(Literals = Tokens.Literals || (Tokens.Literals = {}));
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Substance" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Operator = (function (_super) {
            __extends(Operator, _super);
            function Operator(symbol, region) {
                _super.call(this, region);
                this.symbol = symbol;
            }
            Operator.prototype.getSymbol = function () {
                return this.symbol;
            };
            Operator.prototype.isOperator = function (symbol) {
                if (symbol === void 0) { symbol = null; }
                return !symbol && symbol == this.symbol;
            };
            Operator.scan = function (source) {
                var result;
                switch (source.peek()) {
                    case "@":
                        result = new Operator(source.read(), source.mark());
                        break;
                    case "+":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "+=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "-":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "-=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                            case "->":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "*":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "**":
                                switch (source.peek(3)) {
                                    default:
                                        result = new Operator(source.read(2), source.mark());
                                        break;
                                    case "**=":
                                        result = new Operator(source.read(3), source.mark());
                                        break;
                                }
                                break;
                            case "*=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "/":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "/=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        ;
                        break;
                    case "=":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "==":
                                result = new Operator(source.read(2), source.mark());
                                break;
                            case "=>":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "^":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "^=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "|":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "||":
                                result = new Operator(source.read(2), source.mark());
                                break;
                            case "|=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "&":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "&&":
                                result = new Operator(source.read(2), source.mark());
                                break;
                            case "&=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "!":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "!=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "<":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "<<":
                                switch (source.peek(3)) {
                                    default:
                                        result = new Operator(source.read(2), source.mark());
                                        break;
                                    case "<<=":
                                        result = new Operator(source.read(3), source.mark());
                                        break;
                                }
                                break;
                            case "<=":
                                switch (source.peek(4)) {
                                    default:
                                        result = new Operator(source.read(2), source.mark());
                                        break;
                                    case "<==>":
                                        result = new Operator(source.read(4), source.mark());
                                        break;
                                }
                                break;
                        }
                        break;
                    case ">":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case ">>":
                                switch (source.peek(3)) {
                                    default:
                                        result = new Operator(source.read(2), source.mark());
                                        break;
                                    case ">>=":
                                        result = new Operator(source.read(3), source.mark());
                                        break;
                                }
                                break;
                            case ">=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case ":":
                        switch (source.peek(2)) {
                            default:
                                result = null;
                                break;
                            case ":=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                            case "::":
                                switch (source.peek(3)) {
                                    default:
                                        source.raise("Undefined operator \"::\"");
                                        break;
                                    case "::=":
                                        result = new Operator(source.read(3), source.mark());
                                        break;
                                }
                                break;
                        }
                        break;
                    case ".":
                        switch (source.peek(2)) {
                            default:
                                result = null;
                                break;
                            case "..":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "%":
                        switch (source.peek(2)) {
                            default:
                                result = new Operator(source.read(), source.mark());
                                break;
                            case "%=":
                                result = new Operator(source.read(2), source.mark());
                                break;
                        }
                        break;
                    case "~":
                        result = new Operator(source.read(), source.mark());
                        break;
                    case "?":
                        result = new Operator(source.read(), source.mark());
                        break;
                    default:
                        result = null;
                        break;
                }
                return result;
            };
            return Operator;
        })(Tokens.Substance);
        Tokens.Operator = Operator;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Substance" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Separator = (function (_super) {
            __extends(Separator, _super);
            function Separator(symbol, region) {
                _super.call(this, region);
                this.symbol = symbol;
            }
            Separator.prototype.getSymbol = function () {
                return this.symbol;
            };
            Separator.prototype.isSeparator = function (symbol) {
                if (symbol === void 0) { symbol = null; }
                return !symbol || this.symbol == symbol;
            };
            Separator.scan = function (source) {
                var result;
                switch (source.peek()) {
                    case ".":
                    case ":":
                    case ";":
                    case ",":
                    case "[":
                    case "]":
                    case "(":
                    case ")":
                    case "{":
                    case "}":
                        result = new Separator(source.read(), source.mark());
                        break;
                    default:
                        result = null;
                }
                return result;
            };
            return Separator;
        })(Tokens.Substance);
        Tokens.Separator = Separator;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Gap" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Comment = (function (_super) {
            __extends(Comment, _super);
            function Comment(content, region) {
                _super.call(this, region);
                this.content = content;
            }
            Comment.scan = function (source) {
                var result;
                switch (source.peek(2)) {
                    case "//":
                        result = "";
                        source.read(2);
                        while (source.peek() != "\n")
                            result += source.read();
                        break;
                    case "/*":
                        result = "";
                        source.read(2);
                        while (source.peek(2) != "*/")
                            result += source.read();
                        break;
                    default:
                        result = null;
                }
                return result ? new Comment(result, source.mark()) : null;
            };
            return Comment;
        })(Tokens.Gap);
        Tokens.Comment = Comment;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Gap" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Whitespace = (function (_super) {
            __extends(Whitespace, _super);
            function Whitespace(endsLine, region) {
                _super.call(this, region);
                this.endsLine = endsLine;
            }
            Whitespace.prototype.getEndsLine = function () { return this.endsLine; };
            Whitespace.scan = function (source) {
                var result;
                do {
                    switch (source.peek()) {
                        case "\n":
                            source.read();
                            result = new Whitespace(true, source.mark());
                            break;
                        case "\r":
                        case "\t":
                        case " ":
                            source.read();
                            continue;
                        default:
                            result = new Whitespace(false, source.mark());
                    }
                } while (false);
                return result;
            };
            return Whitespace;
        })(Tokens.Gap);
        Tokens.Whitespace = Whitespace;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Region" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="Substance" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var EndOfFile = (function (_super) {
            __extends(EndOfFile, _super);
            function EndOfFile(region) {
                _super.call(this, region);
            }
            EndOfFile.scan = function (source) {
                var result;
                switch (source.peek()) {
                    case "\0":
                        source.read();
                        result = new EndOfFile(source.mark());
                        break;
                    default:
                        result = null;
                }
                return result;
            };
            return EndOfFile;
        })(Tokens.Substance);
        Tokens.EndOfFile = EndOfFile;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Error/Handler" />
/// <reference path="../Utilities/Iterator" />
/// <reference path="../IO/Reader" />
/// <reference path="Source" />
/// <reference path="Token" />
/// <reference path="EndOfFile" />
/// <reference path="Identifier" />
/// <reference path="Comment" />
/// <reference path="Literal" />
/// <reference path="Literals/String" />
/// <reference path="Separator" />
/// <reference path="Whitespace" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var Lexer = (function () {
            function Lexer(reader, errorHandler) {
                this.errorHandler = errorHandler;
                this.source = new Tokens.Source(reader, errorHandler);
            }
            Lexer.prototype.next = function () {
                var result = null;
                if (!((result = Tokens.EndOfFile.scan(this.source)) ||
                    (result = Tokens.Whitespace.scan(this.source)) ||
                    (result = Tokens.Comment.scan(this.source)) ||
                    (result = Tokens.Operator.scan(this.source)) ||
                    (result = Tokens.Separator.scan(this.source)) ||
                    (result = Tokens.Literals.String.scan(this.source)) ||
                    (result = Tokens.Literals.Number.scan(this.source)) ||
                    (result = Tokens.Identifier.scan(this.source)) ||
                    false))
                    this.source.raise("Unrecognized token.");
                return result;
            };
            return Lexer;
        })();
        Tokens.Lexer = Lexer;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
/// <reference path="../Utilities/Iterator" />
/// <reference path="../Utilities/BufferedIterator" />
/// <reference path="Token" />
/// <reference path="Gap" />
/// <reference path="Substance" />
/// <reference path="Whitespace" />
var Magic;
(function (Magic) {
    var Tokens;
    (function (Tokens) {
        var GapRemover = (function () {
            function GapRemover(backend) {
                this.backend = new Magic.Utilities.BufferedIterator(backend);
            }
            GapRemover.prototype.next = function () {
                var pre = new Array();
                while (this.backend.peek() instanceof Tokens.Gap) {
                    pre.push(this.backend.next());
                }
                var result;
                if (!(this.backend.peek() instanceof Tokens.Substance))
                    throw "Lexical Error: Missing end of file token.";
                result = this.backend.next();
                var post = new Array();
                while (this.backend.peek() instanceof Tokens.Gap) {
                    var next = this.backend.next();
                    post.push(next);
                    if (next instanceof Tokens.Whitespace && next.getEndsLine()) {
                        break;
                    }
                }
                result.setPregap(pre);
                result.setPostgap(post);
                return result;
            };
            return GapRemover;
        })();
        Tokens.GapRemover = GapRemover;
    })(Tokens = Magic.Tokens || (Magic.Tokens = {}));
})(Magic || (Magic = {}));
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var Modifier = (function () {
                function Modifier(parent) {
                    if (parent === void 0) { parent = null; }
                    this.parent = parent;
                }
                Modifier.prototype.verify = function (value, child) {
                    if (child === void 0) { child = null; }
                    this.child = child;
                    return this.parent != null ? this.parent.verify(value, this) : this.test(value);
                };
                Modifier.prototype.test = function (value) {
                    return this.testChild(value);
                };
                Modifier.prototype.testChild = function (value) {
                    return this.child != null && this.child.test(value);
                };
                return Modifier;
            })();
            Constraints.Modifier = Modifier;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Modifier" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var Constraint = (function (_super) {
                __extends(Constraint, _super);
                function Constraint(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                return Constraint;
            })(Constraints.Modifier);
            Constraints.Constraint = Constraint;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var CompareConstraint = (function (_super) {
                __extends(CompareConstraint, _super);
                function CompareConstraint(correct, comparer, parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                    this.correct = correct;
                    this.comparer = comparer;
                }
                CompareConstraint.prototype.test = function (value) {
                    return this.comparer(value, this.correct);
                };
                return CompareConstraint;
            })(Constraints.Constraint);
            Constraints.CompareConstraint = CompareConstraint;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Modifier" />
/// <reference path="CompareConstraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var EqualModifier = (function (_super) {
                __extends(EqualModifier, _super);
                function EqualModifier(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                EqualModifier.prototype.To = function (correct) {
                    var comparer = function (objectA, objectB) {
                        return objectA === objectB;
                    };
                    return new Constraints.CompareConstraint(correct, comparer, this);
                };
                return EqualModifier;
            })(Constraints.Modifier);
            Constraints.EqualModifier = EqualModifier;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var FalseConstraint = (function (_super) {
                __extends(FalseConstraint, _super);
                function FalseConstraint(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                FalseConstraint.prototype.test = function (value) {
                    return value === false;
                };
                return FalseConstraint;
            })(Constraints.Constraint);
            Constraints.FalseConstraint = FalseConstraint;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var TrueConstraint = (function (_super) {
                __extends(TrueConstraint, _super);
                function TrueConstraint(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                TrueConstraint.prototype.test = function (value) {
                    return value === true;
                };
                return TrueConstraint;
            })(Constraints.Constraint);
            Constraints.TrueConstraint = TrueConstraint;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var NullConstraint = (function (_super) {
                __extends(NullConstraint, _super);
                function NullConstraint(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                NullConstraint.prototype.test = function (value) {
                    return value == null;
                };
                return NullConstraint;
            })(Constraints.Constraint);
            Constraints.NullConstraint = NullConstraint;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Modifier" />
/// <reference path="CompareConstraint" />
/// <reference path="FalseConstraint" />
/// <reference path="TrueConstraint" />
/// <reference path="EqualModifier" />
/// <reference path="NullConstraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var NotModifier = (function (_super) {
                __extends(NotModifier, _super);
                function NotModifier(parent) {
                    if (parent === void 0) { parent = null; }
                    _super.call(this, parent);
                }
                NotModifier.prototype.test = function (value) {
                    return !(this.testChild(value));
                };
                NotModifier.prototype.Null = function () { return new Constraints.NullConstraint(this); };
                NotModifier.prototype.False = function () { return new Constraints.FalseConstraint(this); };
                NotModifier.prototype.True = function () { return new Constraints.TrueConstraint(this); };
                NotModifier.prototype.Equal = function () { return new Constraints.EqualModifier(this); };
                NotModifier.prototype.Not = function () { return new NotModifier(this); };
                return NotModifier;
            })(Constraints.Modifier);
            Constraints.NotModifier = NotModifier;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="FalseConstraint" />
/// <reference path="TrueConstraint" />
/// <reference path="NullConstraint" />
/// <reference path="EqualModifier" />
/// <reference path="NotModifier" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Constraints;
        (function (Constraints) {
            var Is = (function () {
                function Is() {
                }
                Is.True = function () { return new Constraints.TrueConstraint(); };
                Is.False = function () { return new Constraints.FalseConstraint(); };
                Is.Null = function () { return new Constraints.NullConstraint(); };
                Is.Equal = function () { return new Constraints.EqualModifier(); };
                Is.Not = function () { return new Constraints.NotModifier(); };
                return Is;
            })();
            Constraints.Is = Is;
        })(Constraints = Unit.Constraints || (Unit.Constraints = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Test = (function () {
            function Test(name, action) {
                this.name = name;
                this.action = action;
            }
            Test.prototype.getName = function () { return this.name; };
            Test.prototype.getAction = function () { return this.action; };
            Test.prototype.run = function () {
                this.action();
            };
            Test.prototype.toString = function () {
                return this.name;
            };
            return Test;
        })();
        Unit.Test = Test;
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="./Constraints/Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var TestFailedError = (function () {
            function TestFailedError(value, constraint, message) {
                if (message === void 0) { message = null; }
                this.value = value;
                this.constraint = constraint;
                this.message = message;
                this.name = "TestFailedError";
            }
            TestFailedError.prototype.getValue = function () { return this.value; };
            TestFailedError.prototype.getConstraint = function () { return this.constraint; };
            TestFailedError.prototype.getName = function () { return this.name; };
            TestFailedError.prototype.getTest = function () { return this.test; };
            TestFailedError.prototype.setTest = function (test) {
                this.message = test.getName();
                this.test = test;
            };
            TestFailedError.prototype.toString = function () {
                return this.name + ": " + this.test.getName();
            };
            return TestFailedError;
        })();
        Unit.TestFailedError = TestFailedError;
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="Test" />
/// <reference path="TestFailedError" />
/// <reference path="./Constraints/Constraint" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Fixture = (function () {
            function Fixture(name) {
                this.name = name;
                this.tests = [];
            }
            Fixture.prototype.getName = function () { return this.name; };
            Fixture.prototype.add = function (name, action) {
                this.tests.push(new Unit.Test(name, action));
            };
            Fixture.prototype.run = function () {
                var failures = [];
                var success = true;
                this.tests.forEach(function (test) {
                    try {
                        test.run();
                    }
                    catch (TestFailedError) {
                        success = false;
                        TestFailedError.setTest(test);
                        failures.push(TestFailedError);
                    }
                });
                console.log(this.name + ":", success ? "passed" : "failed");
                if (!success) {
                    failures.forEach(function (failure) {
                        console.log("  ->", failure.getTest().toString());
                    });
                }
            };
            Fixture.prototype.expect = function (value, constraint) {
                if (!constraint.verify(value))
                    throw new Unit.TestFailedError(value, constraint);
            };
            return Fixture;
        })();
        Unit.Fixture = Fixture;
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="../Fixture" />
/// <reference path="../Constraints/Is" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Tests;
        (function (Tests) {
            var Is = Unit.Constraints.Is;
            var BooleanTest = (function (_super) {
                __extends(BooleanTest, _super);
                function BooleanTest() {
                    var _this = this;
                    _super.call(this, "BooleanTest");
                    this.add("true is true", function () {
                        _this.expect(true, Is.True());
                    });
                    this.add("false is false", function () {
                        _this.expect(false, Is.False());
                    });
                    this.add("foo === foo (true)", function () {
                        _this.expect("foo" === "foo", Is.True());
                    });
                    this.add("foo === bar (false)", function () {
                        _this.expect("foo" === "bar", Is.False());
                    });
                }
                return BooleanTest;
            })(Unit.Fixture);
            Tests.BooleanTest = BooleanTest;
        })(Tests = Unit.Tests || (Unit.Tests = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="../Fixture" />
/// <reference path="../Constraints/Is" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Tests;
        (function (Tests) {
            var Is = Unit.Constraints.Is;
            var EqualTest = (function (_super) {
                __extends(EqualTest, _super);
                function EqualTest() {
                    var _this = this;
                    _super.call(this, "EqualTest");
                    this.add("true is true", function () {
                        _this.expect(true, Is.Equal().To(true));
                    });
                    this.add("false is false", function () {
                        _this.expect(false, Is.Equal().To(false));
                    });
                    this.add("true is not false", function () {
                        _this.expect(true === false, Is.Equal().To(false));
                    });
                    this.add("false is not true", function () {
                        _this.expect(false === true, Is.Equal().To(false));
                    });
                    this.add("foo equals foo", function () {
                        _this.expect("foo" === "foo", Is.Equal().To(true));
                    });
                    this.add("foo does not equal bar", function () {
                        _this.expect("foo" === "bar", Is.Equal().To(false));
                    });
                    this.add("null === null", function () {
                        _this.expect(null, Is.Equal().To(null));
                    });
                    this.add("undefined === undefined", function () {
                        _this.expect(undefined, Is.Equal().To(undefined));
                    });
                }
                return EqualTest;
            })(Unit.Fixture);
            Tests.EqualTest = EqualTest;
        })(Tests = Unit.Tests || (Unit.Tests = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="../Fixture" />
/// <reference path="../Constraints/Is" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Tests;
        (function (Tests) {
            var Is = Unit.Constraints.Is;
            var NullTest = (function (_super) {
                __extends(NullTest, _super);
                function NullTest() {
                    var _this = this;
                    _super.call(this, "NullTest");
                    this.add("null test 1", function () {
                        _this.expect(null, Is.Null());
                    });
                    this.add("null test 2", function () {
                        var s = null;
                        _this.expect(s, Is.Null());
                    });
                }
                return NullTest;
            })(Unit.Fixture);
            Tests.NullTest = NullTest;
        })(Tests = Unit.Tests || (Unit.Tests = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="../Fixture" />
/// <reference path="../Constraints/Is" />
var Magic;
(function (Magic) {
    var Unit;
    (function (Unit) {
        var Tests;
        (function (Tests) {
            var Is = Unit.Constraints.Is;
            var NotTest = (function (_super) {
                __extends(NotTest, _super);
                function NotTest() {
                    var _this = this;
                    _super.call(this, "NotTest");
                    this.add("foobar is not null", function () {
                        _this.expect("foobar", Is.Not().Null());
                    });
                    this.add("foobar is not equal to moobar", function () {
                        _this.expect("foobar", Is.Not().Equal().To("moobar"));
                    });
                    this.add("foo === bar is not true", function () {
                        _this.expect("foo" === "bar", Is.Not().True());
                    });
                    this.add("foo !== bar is not false", function () {
                        _this.expect("foo" !== "bar", Is.Not().True());
                    });
                }
                return NotTest;
            })(Unit.Fixture);
            Tests.NotTest = NotTest;
        })(Tests = Unit.Tests || (Unit.Tests = {}));
    })(Unit = Magic.Unit || (Magic.Unit = {}));
})(Magic || (Magic = {}));
/// <reference path="./Unit/Fixture" />
/// <reference path="./Unit/Tests/BooleanTest" />
/// <reference path="./Unit/Tests/NullTest" />
/// <reference path="./Unit/Tests/EqualTest" />
/// <reference path="./Unit/Tests/NotTest" />
var Magic;
(function (Magic) {
    var SelfTest = (function () {
        function SelfTest() {
        }
        SelfTest.run = function () {
            var tests = [
                new Magic.Unit.Tests.BooleanTest(),
                new Magic.Unit.Tests.NullTest(),
                new Magic.Unit.Tests.EqualTest(),
                new Magic.Unit.Tests.NotTest()
            ];
            tests.forEach(function (test) {
                test.run();
            });
        };
        return SelfTest;
    })();
    Magic.SelfTest = SelfTest;
})(Magic || (Magic = {}));
/// <reference path="../typings/node/node" />
/// <reference path="Error/ConsoleHandler" />
/// <reference path="Tokens/Lexer" />
/// <reference path="IO/Reader" />
/// <reference path="SelfTest" />
var fs = require("fs");
var Magic;
(function (Magic) {
    var Program = (function () {
        function Program(commands) {
            this.commands = commands;
            this.defaultCommand = "self-test";
            this.runHelper(this.defaultCommand, null);
        }
        Program.prototype.openReader = function (path) {
            return path.slice(-4) == ".ooc" ? new Magic.IO.FileReader(path) : new Magic.IO.FolderReader(path, "*.ooc");
        };
        Program.prototype.openLexer = function (path) {
            return new Magic.Tokens.Lexer(this.openReader(path), new Magic.Error.ConsoleHandler());
        };
        Program.prototype.runHelper = function (command, commands) {
            switch (command) {
                case "compile":
                case "verify":
                    var lexer = this.openLexer(commands.pop());
                    break;
                case "self-test":
                    Magic.SelfTest.run();
                    break;
                case "version":
                    console.log("magic " + this.getVersion());
                    break;
                case "help":
                    break;
                default:
                    commands.push(command);
                    command = undefined;
                    this.runHelper(this.defaultCommand, commands);
                    break;
            }
            if (command)
                this.defaultCommand = command;
        };
        Program.prototype.run = function () {
            var command;
            while (command = this.commands.shift()) {
                this.runHelper(command, this.commands);
            }
        };
        Program.prototype.getVersion = function () {
            return "0.2";
        };
        return Program;
    })();
    Magic.Program = Program;
})(Magic || (Magic = {}));
try {
    var magic = new Magic.Program(process.argv);
    console.log("magic " + magic.getVersion());
}
catch (Error) {
    console.log(Error.toString());
}
//# sourceMappingURL=magic.js.map